{"name":"Subspace","tagline":"Lightweight vector and matrix math library for OpenGL programming in Scala.","body":"Subspace\r\n========\r\n\r\nLightweight vector and matrix math library for OpenGL programming in Scala.\r\n\r\nFor more details, see: http://jpbetz.github.io/subspace/\r\n\r\nInspired by [glm](http://glm.g-truc.net/0.9.6/index.html), Subspace makes the vector and matrix computations that needs\r\nto be performed on the CPU a bit easier.  It provides convenience features from shader programming like\r\n[swizzle operators](https://www.opengl.org/wiki/Data_Type_%28GLSL%29#Swizzling) as well as a comprehensive set of\r\noperations for graphics programming,  including replacements for functions that have been deprecated by OpenGL.\r\n\r\nTo minimize it's footprint, this library has no dependencies.  Is intended for use with OpenGL, via JVM bindings such as\r\n[LWJGL](http://www.lwjgl.org/),  but could be used with any graphics API.\r\n\r\nUsage\r\n-----\r\n\r\n### Vectors\r\n\r\nAll vector classes are case classes with companion objects that provide additional functions and constructors.\r\n\r\n```scala\r\nval position = Vector3(0, 0, 1)\r\nval origin = Vector3.fill(0)\r\n```\r\n\r\nMathematical operators can be used for operations that make sense mathematically, e.g.:\r\n\r\n```scala\r\nval v1 = Vector3(3.2f, 1.5f, 0)\r\nval v2 = Vector3(5, 0.5f, 0)\r\nval v3 = -(v1/3f + v2)\r\n```\r\n\r\nAnd all mathematical operators have an equivalent method.  E.g. `v1 + v2` can also be written as `v1.add(v2)`.\r\n\r\nWhere mathematical operators cannot be overloaded in a clear and unambiguous way, the operator is not\r\noverloaded.  For example,  to multiply a vector with a scalar use: `vec3 * 3.0f`,  but to compute the product of two\r\nvectors,  `*` is not available.  Instead, use `v1.dotProduct(v2)`, `v1.crossProduct(v2)` or `v1.scale(v2)`\r\n(for component-wise multiplication).\r\n\r\nVector classes also contain a variety of convenience methods, e.g.:\r\n\r\n* `v1.distanceTo(v2)`\r\n* `v1.lerp(v2, 0.5f)`\r\n* `v1.clamp(min, max)`\r\n\r\n### Matrices\r\n\r\nMatrices are usually constructed using the convenience methods on the companion object.\r\n\r\n```scala\r\nval perspectiveMatrix = Matrix4x4.forPerspective(scala.math.Pi.toFloat/3f, 1f, 1f, 0.001f, 1000f)\r\nval worldToViewMatrix = Matrix4x4.forRotation(cameraRotation)\r\n```\r\n\r\nMatrices can be combined using matrix multiplication.\r\n\r\n```scala\r\nval modelToWorldMatrix = Matrix4x4.forTranslation(modelPosition) * Matrix4x4.forRotation(modelRotation)\r\nval modelViewMatrix = modelToWorldMatrix * worldToViewMatrix\r\n```\r\n\r\nMatrices also have convenience methods for common graphics operations:\r\n\r\n```scala\r\nval normalViewMatrix = modelViewMatrix.normalMatrix // same as modelViewMatrix.inverse.transpose\r\n```\r\n\r\n### Rotations\r\n\r\nRotations can be managed using any of the following:\r\n\r\n* Axis angle\r\n* Euler angles\r\n* Quaternions\r\n\r\nInternally,  Quaternions are used to handle all rotations.  But Quaternions can be constructed from an axis angle or\r\nEuler angles.\r\n\r\nFor example, to create a transformation matrix from an axis angle:\r\n\r\n```scala\r\nMatrix4x4.forRotation(Quaternion.forAxisAngle(Orientation.x, scala.math.Pi.toFloat/4))\r\n```\r\n\r\nAnd to create one from Euler angles:\r\n\r\n```scala\r\nMatrix4x4.forRotation(Quaternion.forEuler(Vector3(scala.math.Pi.toFloat/2, 0, 0)))\r\n```\r\n\r\nAll angles are in radians.\r\n\r\n### Swizzle operators\r\n\r\nSwizzle operators allow a new vector to be created from an existing vector by specifying the dimensions from the existing\r\nvector to use to create the new vector.  Dimensions can be specified in any order and can be repeated.  If few dimensions\r\nare specified, a lower dimension vector is created.\r\n\r\nSwizzle Operator | Equivalent code\r\n-----------------|----------------\r\n`vec3.zxy`       | `Vector3(vec3.z, vec3.y, vec3.z)`\r\n`vec4.xz`        | `Vector2(vec4.x, vec4.z)`\r\n`vec4.yyy`       | `Vector3(vec4.y, vec4.y, vec4.y)`\r\n\r\nVectors can be constructed from other vectors.  Similar to GLSL constructors:\r\n\r\nConvenience Constructors | Equivalent code\r\n-------------------------|----------------\r\n`Vector4(vec3, 1)`       | `Vector4(vec3.x, vec3.y, vec3.z, 1)`\r\n`Vector4(1, vec2, 1)`    | `Vector4(1, vec2.x, vec2.y, 1)`\r\n\r\n\r\nConstructors and swizzle operators can be used together to reshape and resize vectors:\r\n\r\nSwizzle Operators + Constructors | Equivalent code\r\n---------------------------------|----------------\r\n`Vector4(0, vec2.yx, 1)`         | `Vector4(0, vec2.y, vec2.x, 1)`\r\n`Vector4(vec3.zxy, 1)`           | `Vector4(vec3.z, vec3.y, vec3.x, 1)`\r\n\r\n### ByteBuffers\r\n\r\nIntegrating with graphics API bindings for the JVM, such as LWJGL, may require allocating byte buffers for vectors\r\nand matrices.  Usually so they can be passed to shaders as uniforms.\r\n\r\nTo allocate a new byte buffer:\r\n\r\n```scala\r\nval cameraPosition = Vector3(10, 10, 5)\r\n...\r\nval cameraPositionBuffer = cameraPosition.allocateBuffer\r\n```\r\n\r\nTo update an existing byte buffer:\r\n\r\n```scala\r\ncameraPosition.updateBuffer(cameraPositionBuffer)\r\n```\r\n\r\nTo read from a byte buffer:\r\n\r\n```scala\r\nMatrix4x4.fromBuffer(transformBuffer)\r\n```\r\n\r\nOpenGL Programming in Scala\r\n---------------------------\r\n\r\nSubspace works well with LWJGL, a library providing access the full OpenGL API from the JVM.\r\n\r\nThis library can be used with version 2 and 3 of LWJGL.  While LWJGL 2 provides a utility library with vector\r\nand matrix classes, it is rather incomplete.  And in LWJGL 3, they are removing the utility library entirely.\r\n\r\nTo use this library with LWJGL,  simply build whatever types are needed and then use the toBuffer methods to produce the\r\nByteBuffers needed by LWJGL.  E.g.:\r\n\r\n```scala\r\nval modelViewMatrixBuffer = Matrix4x4.allocateEmptyBuffer\r\n...\r\nval modelViewMatrix = Matrix4x4.forTranslationRotationScale(modelPosition, modelQuaternion, modelScale)\r\nmodelViewMatrix.updateBuffer(modelViewMatrixBuffer)\r\n...\r\nglUniformMatrix4(modelViewMatrixUniform, false, modelViewMatrixBuffer)\r\n```\r\n\r\nBuffers can also be allocated from existing objects, e.g.:\r\n\r\n```scala\r\nval perspectiveMatrixBuffer = perspectiveMatrix.allocateBuffer\r\n...\r\nglUniformMatrix4(perspectiveMatrixUniform, false, perspectiveMatrixBuffer)\r\n```\r\n\r\nAnd buffers can be read using companion objects, e.g.:\r\n\r\n```scala\r\nval position = Vector3.fromBuffer(byteBuffer)\r\n```\r\n\r\nQuestions and Feedback\r\n----------------------\r\n\r\nPlease open github issues with any questions or feedback.  Contributions welcome in the form of pull requests for\r\nissues/features.  Please open an issue explaining a planned change so it can be discussed before coding up and\r\nsubmitting a pull request.\r\n\r\nDesign\r\n------\r\n\r\nGoals:\r\n\r\n* Be good at one thing.  Provide the vector and matrix types and operations to drive a GPU from the CPU, and nothing else.\r\n* Consistent and complete.  Shaders and libraries for other languages have been studied to make sure all the convenience operations developers expect have been included.\r\n* Scala idomatic. Immutable case classes for all vector and matrix types. Carefully defined operator overloading for natural looking mathematical expressions.\r\n* Minimal footprint.  No dependencies.\r\n\r\nNon-goals:\r\n\r\n* Provide Scala bindings for OpenGL\r\n* Write a graphics/game engine\r\n* Write a general purpose linear algebra library\r\n\r\nCurrent Limitations\r\n-------------------\r\n\r\n* All types are currently reference types.  This may have negative performance implications.  While scala does allow\r\n  stack allocated value types to be defined by extending AnyVal,  AnyVal can only be used for single field types, not\r\n  multi field types like Vector2.\r\n  Maybe if/when [Java adds value types](http://cr.openjdk.java.net/~jrose/values/values-0.html),\r\n  scala will provide a way to stack allocate these types?\r\n\r\nTODO\r\n----\r\n\r\n* [ ] Publish to maven central\r\n* [ ] Flesh out scaladoc\r\n* [ ] Integrate with scala collection types (Product, Seq, ??)\r\n* [ ] Implement projection/reflection convenience methods on Vector3\r\n* [ ] Add Color and UV coordinate related conveniences.  Might be as simple as adding swizzle operators (rgba, stpq) to Vector3 and Vector4.\r\n\r\nReferences\r\n----------\r\n\r\n* http://glm.g-truc.net/0.9.6/index.html\r\n* https://www.opengl.org/wiki/Data_Type_%28GLSL%29#Swizzling\r\n* https://github.com/ra4king/LWJGL-OpenGL-Utils/tree/master/src/com/ra4king/opengl/util/math\r\n* http://developer.android.com/reference/android/opengl/Matrix.html\r\n* http://docs.unity3d.com/ScriptReference/index.html\r\n* https://github.com/mrdoob/three.js/tree/master/src/math\r\n* http://cr.openjdk.java.net/~jrose/values/values-0.html\r\n\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}